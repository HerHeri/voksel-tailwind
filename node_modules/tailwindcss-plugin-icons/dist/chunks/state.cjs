'use strict';

var path = require('path');
var fs = require('fs');
var shared = require('./shared.cjs');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class IconifyFileCache {
  constructor(cacheDir) {
    __publicField(this, "cacheDir");
    __publicField(this, "size");
    this.cacheDir = cacheDir;
    if (fs.existsSync(this.cacheDir)) {
      this.size = fs.readdirSync(this.cacheDir).length;
    } else {
      this.size = 0;
      fs.mkdirSync(this.cacheDir);
    }
  }
  clear() {
    const files = fs.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path.resolve(this.cacheDir, file);
      fs.unlinkSync(filePath);
    }
    this.size = 0;
  }
  delete(key) {
    const filePath = path.resolve(this.cacheDir, shared.uriToFilename(key));
    if (!fs.existsSync(filePath)) {
      return false;
    }
    fs.unlinkSync(filePath);
    this.size--;
    return true;
  }
  forEach(callbackfn, thisArg = this) {
    for (const [key, value] of this) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  get(key) {
    const filePath = path.resolve(this.cacheDir, shared.uriToFilename(key));
    if (!fs.existsSync(filePath)) {
      return;
    }
    return shared.readJson(filePath);
  }
  set(key, iconifyJson) {
    const filePath = path.resolve(this.cacheDir, shared.uriToFilename(key));
    if (fs.existsSync(filePath)) {
      return this;
    }
    this.size++;
    fs.writeFileSync(filePath, JSON.stringify(iconifyJson));
    return this;
  }
  has(key) {
    const filePath = path.resolve(this.cacheDir, shared.uriToFilename(key));
    return fs.existsSync(filePath);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  *keys() {
    yield* fs.readdirSync(this.cacheDir);
  }
  *values() {
    const files = fs.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path.resolve(this.cacheDir, file);
      yield shared.readJson(filePath);
    }
  }
  *[Symbol.iterator]() {
    const files = fs.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path.resolve(this.cacheDir, file);
      yield [file, shared.readJson(filePath)];
    }
  }
  get [Symbol.toStringTag]() {
    return `IconifyFileCache(size=${this.size})`;
  }
}

const SCALE = Symbol("Icon-specific scaling");
const cache = new IconifyFileCache(path.resolve(__dirname, "cache"));

exports.SCALE = SCALE;
exports.cache = cache;
