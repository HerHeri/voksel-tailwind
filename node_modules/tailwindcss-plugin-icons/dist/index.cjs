'use strict';

require('crypto');

var child_process = require('child_process');
var fs = require('fs');
var path = require('path');
var shared = require('./chunks/shared.cjs');
var state = require('./chunks/state.cjs');
var flattenColorPalette = require('tailwindcss/lib/util/flattenColorPalette');
var plugin = require('tailwindcss/plugin');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var child_process__default = /*#__PURE__*/_interopDefault(child_process);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var flattenColorPalette__default = /*#__PURE__*/_interopDefault(flattenColorPalette);
var plugin__default = /*#__PURE__*/_interopDefault(plugin);

const URL_VAR_NAME = "--tw-plugin-icons-url";
function getIconDimensions(icon, scale) {
  return {
    width: `${icon.width / icon.height * scale}em`,
    height: `${scale}em`
  };
}
function getIconCss(icon, cssDefaults) {
  const iconUrl = shared.iconToDataUrl(icon);
  const iconDimensions = getIconDimensions(icon, cssDefaults[state.SCALE]);
  if (icon.mode === "mask") {
    return {
      [URL_VAR_NAME]: iconUrl,
      mask: `var(${URL_VAR_NAME}) no-repeat`,
      maskSize: "100% 100%",
      backgroundColor: "currentColor",
      ...iconDimensions,
      ...cssDefaults
    };
  }
  return {
    [URL_VAR_NAME]: iconUrl,
    background: `var(${URL_VAR_NAME}) no-repeat`,
    backgroundSize: "100% 100%",
    ...iconDimensions,
    ...cssDefaults
  };
}
function getIconCssAsColorFunction(icon, cssDefaults) {
  return (color) => {
    return {
      [URL_VAR_NAME]: shared.iconToDataUrl(
        icon,
        icon.body.replace(/currentColor/g, color)
      ),
      background: `var(${URL_VAR_NAME}) no-repeat`,
      backgroundSize: "100% 100%",
      ...getIconDimensions(icon, cssDefaults[state.SCALE]),
      ...cssDefaults
    };
  };
}

function resolveIconSets(iconSetOptionsRecord, callback) {
  var _a;
  const locationsToFetch = [];
  const afterFetchCallbacks = [];
  for (const [iconSetName, iconSetOptions] of Object.entries(
    iconSetOptionsRecord
  )) {
    (_a = iconSetOptions.icons) != null ? _a : iconSetOptions.icons = {};
    const kebabCaseIconSetName = shared.toKebabCase(iconSetName);
    if (!iconSetOptions.location) {
      try {
        const jsonPath = require.resolve(
          `@iconify-json/${kebabCaseIconSetName}/icons.json`
        );
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          shared.readJson(jsonPath)
        );
        continue;
      } catch (e) {
        shared.TailwindcssPluginIconsError.rethrowIfInstanceof(e);
      }
      try {
        const jsonPath = require.resolve(
          `@iconify/json/json/${kebabCaseIconSetName}.json`
        );
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          shared.readJson(jsonPath)
        );
        continue;
      } catch (e) {
        shared.TailwindcssPluginIconsError.rethrowIfInstanceof(e);
      }
      throw new shared.TailwindcssPluginIconsError(
        `Icon set "${iconSetName}" not found. Please see if the name is correct or try installing it with "npm install @iconify-json/${kebabCaseIconSetName}"`
      );
    }
    if (shared.isUri(iconSetOptions.location)) {
      if (state.cache.has(iconSetOptions.location)) {
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          state.cache.get(iconSetOptions.location)
        );
      } else {
        locationsToFetch.push(iconSetOptions.location);
        afterFetchCallbacks.push(() => {
          callback(
            kebabCaseIconSetName,
            iconSetOptions,
            state.cache.get(iconSetOptions.location)
          );
        });
      }
      continue;
    }
    let resolvedLocation;
    try {
      resolvedLocation = require.resolve(iconSetOptions.location);
    } catch {
      resolvedLocation = path__default.default.resolve(iconSetOptions.location);
    }
    if (!fs__default.default.existsSync(resolvedLocation)) {
      throw new shared.TailwindcssPluginIconsError(
        `Failed to find icon set at location "${iconSetOptions.location}"`
      );
    }
    callback(
      kebabCaseIconSetName,
      iconSetOptions,
      shared.readJson(resolvedLocation)
    );
    continue;
  }
  if (!locationsToFetch.length) {
    return;
  }
  child_process__default.default.execFileSync(
    "node",
    [path__default.default.resolve(__dirname, "fetch.mjs"), state.cache.cacheDir, ...locationsToFetch],
    {
      stdio: "pipe"
    }
  );
  afterFetchCallbacks.forEach((cb) => cb());
}
const addIconToComponents = (components, backgroundComponents) => ({
  iconifyJson,
  iconName,
  iconSetName,
  prefix,
  scale,
  cssDefaults = {}
}) => {
  var _a;
  const loadedIcon = shared.loadIconFromIconifyJson(iconifyJson, iconName);
  Object.defineProperty(cssDefaults, state.SCALE, {
    value: (_a = cssDefaults[state.SCALE]) != null ? _a : typeof scale === "function" ? scale(iconName) : scale,
    enumerable: false,
    writable: false,
    configurable: false
  });
  if (loadedIcon.mode === "bg") {
    backgroundComponents[`${prefix.background}${iconSetName}-${loadedIcon.normalizedName}`] = getIconCssAsColorFunction(
      loadedIcon,
      cssDefaults
    );
  } else {
    components[`.${prefix.mask}${iconSetName}-${loadedIcon.normalizedName}`] = getIconCss(loadedIcon, cssDefaults);
  }
  return loadedIcon;
};
const Icons = plugin__default.default.withOptions((options) => (pluginApi) => {
  const components = {};
  const backgroundComponents = {};
  const addIcon = addIconToComponents(components, backgroundComponents);
  const onResolve = (iconSetName, {
    icons,
    includeAll,
    prefix: { mask = "i-", background = "bg-" } = {},
    scale = 1
  }, iconifyJson) => {
    if (includeAll) {
      Object.keys(iconifyJson.icons).forEach((iconName) => {
        addIcon({
          iconifyJson,
          iconName,
          iconSetName,
          scale,
          prefix: { mask, background }
        });
      });
      if (iconifyJson.aliases) {
        Object.keys(iconifyJson.aliases).forEach((iconName) => {
          addIcon({
            iconifyJson,
            iconName,
            iconSetName,
            scale,
            prefix: { mask, background }
          });
        });
      }
    }
    Object.entries(icons).forEach(([iconName, cssDefaults]) => {
      addIcon({
        iconifyJson,
        iconName,
        iconSetName,
        cssDefaults,
        scale,
        prefix: { mask, background }
      });
    });
  };
  try {
    resolveIconSets(options(pluginApi), onResolve);
  } catch (e) {
    if (e instanceof Error) {
      console.error("[TailwindcssPluginIcons]", e.message);
    }
    return;
  }
  pluginApi.addComponents(components);
  pluginApi.matchComponents(backgroundComponents, {
    values: flattenColorPalette__default.default(pluginApi.theme("colors")),
    type: ["color", "any"]
  });
});

Object.defineProperty(exports, "iconUrl", {
  enumerable: true,
  get: function () { return shared.iconUrl; }
});
Object.defineProperty(exports, "SCALE", {
  enumerable: true,
  get: function () { return state.SCALE; }
});
exports.Icons = Icons;
